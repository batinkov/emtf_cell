#include "emtf/ts/cell/EmtfPort.hpp"
#include <stdlib.h>
#include "emtf/ts/cell/LinksAlignmentReferences.hpp"
#include "swatch/core/MetricConditions.hpp"
#include "emtf/ts/cell/Common.hpp"
#include <map>
#include <string>
#include <vector>
#include <stdexcept>
#include <boost/lexical_cast.hpp>

namespace emtf {


using namespace std;
using namespace log4cplus;

class LinkID_t
{
private:
    map<string, vector<unsigned short> > hash;

public:
    const vector<unsigned short>& operator[](const string& id) const throw(runtime_error) {
        map<string, vector<unsigned short> >::const_iterator it = hash.find(id);

        if(it != hash.end()) {
            return it->second;
        }

        throw runtime_error( "Invalid link name " + id );
    }

    // address from table, Sector +1, Sector +2, Sector +3, Sector +4, Sector +5, Sector +6, Sector -1, Sector -2, Sector -3, Sector -4, Sector -5, Sector -6
    LinkID_t(void) {
        hash[ "me1a_02" ] = {0x021,0x041,0x061,0x081,0x0a1,0x0c1,0x201,0x221,0x241,0x261,0x281,0x2a1};
        hash[ "me1a_03" ] = {0x022,0x042,0x062,0x082,0x0a2,0x0c2,0x202,0x222,0x242,0x262,0x282,0x2a2};
        hash[ "me1a_04" ] = {0x023,0x043,0x063,0x083,0x0a3,0x0c3,0x203,0x223,0x243,0x263,0x283,0x2a3};
        hash[ "me1a_05" ] = {0x024,0x044,0x064,0x084,0x0a4,0x0c4,0x204,0x224,0x244,0x264,0x284,0x2a4};
        hash[ "me1a_06" ] = {0x025,0x045,0x065,0x085,0x0a5,0x0c5,0x205,0x225,0x245,0x265,0x285,0x2a5};
        hash[ "me1a_07" ] = {0x026,0x046,0x066,0x086,0x0a6,0x0c6,0x206,0x226,0x246,0x266,0x286,0x2a6};
        hash[ "me1a_08" ] = {0x027,0x047,0x067,0x087,0x0a7,0x0c7,0x207,0x227,0x247,0x267,0x287,0x2a7};
        hash[ "me1a_09" ] = {0x028,0x048,0x068,0x088,0x0a8,0x0c8,0x208,0x228,0x248,0x268,0x288,0x2a8};
        hash[ "me1b_02" ] = {0x031,0x051,0x071,0x091,0x0b1,0x011,0x211,0x231,0x251,0x271,0x291,0x1f1};
        hash[ "me1b_03" ] = {0x032,0x052,0x072,0x092,0x0b2,0x012,0x212,0x232,0x252,0x272,0x292,0x1f2};
        hash[ "me1b_04" ] = {0x033,0x053,0x073,0x093,0x0b3,0x013,0x213,0x233,0x253,0x273,0x293,0x1f3};
        hash[ "me1b_05" ] = {0x034,0x054,0x074,0x094,0x0b4,0x014,0x214,0x234,0x254,0x274,0x294,0x1f4};
        hash[ "me1b_06" ] = {0x035,0x055,0x075,0x095,0x0b5,0x015,0x215,0x235,0x255,0x275,0x295,0x1f5};
        hash[ "me1b_07" ] = {0x036,0x056,0x076,0x096,0x0b6,0x016,0x216,0x236,0x256,0x276,0x296,0x1f6};
        hash[ "me1b_08" ] = {0x037,0x057,0x077,0x097,0x0b7,0x017,0x217,0x237,0x257,0x277,0x297,0x1f7};
        hash[ "me1b_09" ] = {0x038,0x058,0x078,0x098,0x0b8,0x018,0x218,0x238,0x258,0x278,0x298,0x1f8};
        hash[ "me2_02"  ] = {0x0d1,0x0e1,0x0f1,0x101,0x111,0x121,0x2b1,0x2c1,0x2d1,0x2e1,0x2f1,0x301};
        hash[ "me2_03"  ] = {0x0d2,0x0e2,0x0f2,0x102,0x112,0x122,0x2b2,0x2c2,0x2d2,0x2e2,0x2f2,0x302};
        hash[ "me2_04"  ] = {0x0d3,0x0e3,0x0f3,0x103,0x113,0x123,0x2b3,0x2c3,0x2d3,0x2e3,0x2f3,0x303};
        hash[ "me2_05"  ] = {0x0d4,0x0e4,0x0f4,0x104,0x114,0x124,0x2b4,0x2c4,0x2d4,0x2e4,0x2f4,0x304};
        hash[ "me2_06"  ] = {0x0d5,0x0e5,0x0f5,0x105,0x115,0x125,0x2b5,0x2c5,0x2d5,0x2e5,0x2f5,0x305};
        hash[ "me2_07"  ] = {0x0d6,0x0e6,0x0f6,0x106,0x116,0x126,0x2b6,0x2c6,0x2d6,0x2e6,0x2f6,0x306};
        hash[ "me2_08"  ] = {0x0d7,0x0e7,0x0f7,0x107,0x117,0x127,0x2b7,0x2c7,0x2d7,0x2e7,0x2f7,0x307};
        hash[ "me2_09"  ] = {0x0d8,0x0e8,0x0f8,0x108,0x118,0x128,0x2b8,0x2c8,0x2d8,0x2e8,0x2f8,0x308};
        hash[ "me3_02"  ] = {0x131,0x141,0x151,0x161,0x171,0x181,0x311,0x321,0x331,0x341,0x351,0x361};
        hash[ "me3_03"  ] = {0x132,0x142,0x152,0x162,0x172,0x182,0x312,0x322,0x332,0x342,0x352,0x362};
        hash[ "me3_04"  ] = {0x133,0x143,0x153,0x163,0x173,0x183,0x313,0x323,0x333,0x343,0x353,0x363};
        hash[ "me3_05"  ] = {0x134,0x144,0x154,0x164,0x174,0x184,0x314,0x324,0x334,0x344,0x354,0x364};
        hash[ "me3_06"  ] = {0x135,0x145,0x155,0x165,0x175,0x185,0x315,0x325,0x335,0x345,0x355,0x365};
        hash[ "me3_07"  ] = {0x136,0x146,0x156,0x166,0x176,0x186,0x316,0x326,0x336,0x346,0x356,0x366};
        hash[ "me3_08"  ] = {0x137,0x147,0x157,0x167,0x177,0x187,0x317,0x327,0x337,0x347,0x357,0x367};
        hash[ "me3_09"  ] = {0x138,0x148,0x158,0x168,0x178,0x188,0x318,0x328,0x338,0x348,0x358,0x368};
        hash[ "me4_02"  ] = {0x191,0x1a1,0x1b1,0x1c1,0x1d1,0x1e1,0x371,0x381,0x391,0x3a1,0x3b1,0x3c1};
        hash[ "me4_03"  ] = {0x192,0x1a2,0x1b2,0x1c2,0x1d2,0x1e2,0x372,0x382,0x392,0x3a2,0x3b2,0x3c2};
        hash[ "me4_04"  ] = {0x193,0x1a3,0x1b3,0x1c3,0x1d3,0x1e3,0x373,0x383,0x393,0x3a3,0x3b3,0x3c3};
        hash[ "me4_05"  ] = {0x194,0x1a4,0x1b4,0x1c4,0x1d4,0x1e4,0x374,0x384,0x394,0x3a4,0x3b4,0x3c4};
        hash[ "me4_06"  ] = {0x195,0x1a5,0x1b5,0x1c5,0x1d5,0x1e5,0x375,0x385,0x395,0x3a5,0x3b5,0x3c5};
        hash[ "me4_07"  ] = {0x196,0x1a6,0x1b6,0x1c6,0x1d6,0x1e6,0x376,0x386,0x396,0x3a6,0x3b6,0x3c6};
        hash[ "me4_08"  ] = {0x197,0x1a7,0x1b7,0x1c7,0x1d7,0x1e7,0x377,0x387,0x397,0x3a7,0x3b7,0x3c7};
        hash[ "me4_09"  ] = {0x198,0x1a8,0x1b8,0x1c8,0x1d8,0x1e8,0x378,0x388,0x398,0x3a8,0x3b8,0x3c8};
        hash[ "me1n_03" ] = {0x012,0x032,0x052,0x072,0x092,0x0b2,0x1f2,0x212,0x232,0x252,0x272,0x292};
        hash[ "me1n_06" ] = {0x015,0x035,0x055,0x075,0x095,0x0b5,0x1f5,0x215,0x235,0x255,0x275,0x295};
        hash[ "me1n_09" ] = {0x018,0x038,0x058,0x078,0x098,0x0b8,0x1f8,0x218,0x238,0x258,0x278,0x298};
        hash[ "me2n_03" ] = {0x122,0x0d2,0x0e2,0x0f2,0x102,0x112,0x302,0x2b2,0x2c2,0x2d2,0x2e2,0x2f2};
        hash[ "me2n_09" ] = {0x128,0x0d8,0x0e8,0x0f8,0x108,0x118,0x308,0x2b8,0x2c8,0x2d8,0x2e8,0x2f8};
        hash[ "me3n_03" ] = {0x182,0x132,0x142,0x152,0x162,0x172,0x362,0x312,0x322,0x332,0x342,0x352};
        hash[ "me3n_09" ] = {0x188,0x138,0x148,0x158,0x168,0x178,0x368,0x318,0x328,0x338,0x348,0x358};
        hash[ "me4n_03" ] = {0x1e2,0x192,0x1a2,0x1b2,0x1c2,0x1d2,0x3c2,0x372,0x382,0x392,0x3a2,0x3b2};
        hash[ "me4n_09" ] = {0x1e8,0x198,0x1a8,0x1b8,0x1c8,0x1d8,0x3c8,0x378,0x388,0x398,0x3a8,0x3b8};
    }
} linkIdHash;


Mtf7InputPort::Mtf7InputPort(const string& aID, const uint32_t portId, const string processorName, HAL::PCIExprDevice& driver) :
    InputPort(aID),
    id(aID),
    afDelayReference(InputLinksAlignmentReferences::getReferenceValue(processorName, portId)),
    afDeltaMin(-8),
    afDeltaMax(20),
    driver_(driver),
    link_id_mismatch(registerMetric<string>("linkIdMismatch", swatch::core::NotEqualCondition<string>("none"), swatch::core::NotEqualCondition<string>("none"))),
    linkLogger(Logger::getInstance(config::log4cplusLinkLogger())),
    lockedOld(false),
    alignedOld(false),
    crcOld(false),
    idOld(false)
{
    char lut[256];
    bzero(lut,sizeof(lut));
    lut['1'] = 0;
    lut['2'] = 1;
    lut['3'] = 2;
    lut['4'] = 3;
    lut['5'] = 4;
    lut['6'] = 5;
    if( processorName.length() == 6 ) {
        endcap = ( processorName[4] == '+' ? 0 : 1 );
        sector = lut[ processorName[5] ];
    } else {
        sector = 0;
        endcap = 0;
    }
}

Mtf7InputPort::~Mtf7InputPort()
{
}

void Mtf7InputPort::retrieveMetricValues()
{
    setMetricValue<bool>(mMetricIsLocked, readMetricIsLocked());
    setMetricValue<bool>(mMetricIsAligned, readMetricIsAligned());
    setMetricValue<uint32_t>(mMetricCRCErrors, readMetricCRCErrors());
    setMetricValue<string>(link_id_mismatch, readLinkID());

    logLinkStatus();
}

string Mtf7InputPort::readLinkID(void){
    stringstream mismatches;

    uint64_t result = 0;
    driver_.read64( string("link_id_")+id, &result );

    uint32_t deviceIndex = sector + endcap * 6;

    if( result != linkIdHash[ id ][ deviceIndex ] ) // endcap(); sector();
        mismatches << "read/expect: "<< hex << "0x" << result << "/0x" << linkIdHash[ id ][ deviceIndex ] << dec ;

    if( mismatches.str().length()==0 ) return string("none");

    return mismatches.str();
}


bool Mtf7InputPort::readMetricIsLocked()
{
    const string regName("bc0_err_" + id);

    uint64_t bc0Err;

    driver_.read64(regName, &bc0Err);

    return (0 == bc0Err);
}

bool Mtf7InputPort::readMetricIsAligned()
{
    const string regName("af_delay_" + id);

    uint64_t afDelay;

    driver_.read64(regName, &afDelay);

    bool res = true;

    const int64_t delta = (afDelay - afDelayReference);

    if(   (0x40 <= afDelay)                       // afDelay must be smaller than 0x40
       || (delta < afDeltaMin)
       || (delta > afDeltaMax))
    {
        res = false;
    }

    return res;
}

uint32_t Mtf7InputPort::readMetricCRCErrors()
{
    // TODO: implement the function when the firmware support for this metric is added

    return 0;
}

void Mtf7InputPort::logLinkStatus(bool forceLog)
{
    const bool lockedOk = readMetricIsLocked();
    const bool alignedOk = readMetricIsAligned();
    const bool crcOk = (0 == readMetricCRCErrors());
    const bool idOk = ("none" == readLinkID());

    if(    forceLog
        || (lockedOk  != lockedOld)
        || (alignedOk != alignedOld)
        || (crcOk     != crcOld)
        || (idOk      != idOld) )
    {
        lockedOld = lockedOk;
        alignedOld = alignedOk;
        crcOld = crcOk;
        idOld = idOk;

        // add 1 to the endcap and the sector because in the software they start from 0 and that might be misleading
        string msg = "endcap " + boost::lexical_cast<string>(endcap+1) + ", " + \
                     "sector " + boost::lexical_cast<string>(sector+1) + ", " + \
                     id + " - " + \
                     "locked: " + boolToString(lockedOk) + ", " + \
                     "aligned: " + boolToString(alignedOk) + ", " + \
                     "crc: " + boolToString(crcOk) + ", " + \
                     "id: " + boolToString(idOk);
        LOG4CPLUS_TRACE(linkLogger, LOG4CPLUS_TEXT(msg));
    }
}


Mtf7OutputPort::Mtf7OutputPort(const string& aID, const uint32_t portId, HAL::PCIExprDevice& driver) :
    OutputPort(aID),
    driver_(driver)
{
}

Mtf7OutputPort::~Mtf7OutputPort()
{
}

void Mtf7OutputPort::retrieveMetricValues()
{
    setMetricValue<bool>(mMetricIsOperating, readMetricIsOperating());
}

bool Mtf7OutputPort::readMetricIsOperating()
{
    // TODO: implement the function when the firmware support for this metric is added

    return true;
}

} // namespace

